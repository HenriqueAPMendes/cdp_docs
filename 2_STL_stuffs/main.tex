\section{STL Stuffs}
As estruturas Vector, List e Deque armazenam os elementos em ordem linear,
seguindo a estrutura na qual foram inseridos.

\subsection{Pair}
Combinação de dois valores que podem (ou não) possuir tipos diferentes.
\begin{verbatim}
    pair <type1, type2> Pair_name 
    //Criação de um pair.

    pair <type1, type2> Pair_name (value1, value2) 
    //Criação do um pair com valores já escritos.

    pair pair_name (1, 'a') 
    //Criação de um pair sem pré-determinar os tipos.

    g2 = make_pair(1, 'a')
    g2 = {1, 'a'}
    //Atribuição de um pair (ideal para uso em vectors).
\end{verbatim}

\subsection{Vector}
Vetor de alocação dinâmica, que possui os seguintes comandos principais:
\begin{verbatim}
    begin()
    //Returns an iterator pointing to the first element.

    end() 
    //Returns an iterator pointing to the last element.

    size() 
    //Returns the number of elements in the vector.

    empty() 
    //Returns whether the container is empty.

    front() 
    //Returns a reference to the first element in the vector.

    nome_vec[i] 
    //Returns a reference to the element at position ‘i’ in the vector.

    push_back(element) 
    //Push the elements into a vector from the back. (copia o elemento)

    pop_back() 
    //Remove elements from a vector from the back.

    insert(index, val) 
    //Inserts new elements before the element at the specified position
    //No casos envolvendo inserção de um caracter em uma string, deve-se usar 
    str.insert(index, 1, 'char');

    clear() 
    //Destroy all the elements of the vector.

    erase(posIn, posFinal) 
    //Remove elements from a container from the specified range (used with iterators).
    - Feito em tempo O(n). Set faz esse processo em tempo O(1).

    emplace(position /*Iterator*/, element); 
    //Insert a element at the position (constrói o elemento).

    push_back(value); 
    //Insert a element at the end of the vector.

    auto it = find(vetor.begin(), vetor.end(), valorProcurado);
    //Encontra o iterator da posição que tem valor = valorProcurado.
    //Retorna vetor.end() caso não encontre.
\end{verbatim}


\subsection{Deque}
    Lista que possui dois fins (um no começo e outro no final).
    - Parecido com a fila, mas faz a inserção/remoção do começo/fim em O(1).
\begin{verbatim}
    deque_name.insert (iterator, value);
    //Insere o elemento na posição do itarator.

    deque_name.push_front(value);
    deque_name.push_back(value);
    //Adiciona um elemento no começo/fim do deque.

    deque_name.pop_front();
    deque_name.pop_back();
    //Retira um elemento do começo/fim do deque. (possui tipo void).

    deque_name.clear();
    //Exclui todos os elementos do deque.

    deque_name.erase(iterator1, iterator2);
    //Exclui os elementos do intervalo delimitado.

    deque_name.empty();
    //Verifica se o deque está vazio.

    deque_name.front();
    deque_name.back();
    //Acessa os elementos do começo/fim do deque.

    deque_name.size();
    //Verifica o tamanho do deque.
\end{verbatim}

\subsection{Stack}

\begin{verbatim}
    stack<int> s;
    s.push(x);
    int x = s.top();
    s.pop();
\end{verbatim}

\subsection{Queue}

\begin{verbatim}
    queue<int> q;
    q.push(x);
    int x = q.front();
    q.pop();
\end{verbatim}

\subsection{Priority Queue}

\subsection{Map}
\begin{verbatim}
    for(auto [key, value] : map)

    map.count(x);
    // checa se x está no mapa como chave retorna 0 se não estiver

    map.find(x);
    // procura value x, retorna iterador, retorna map.end() se não encontrar

    map.lower_bound(x);
    // retorna iterador para último elemento <= x

    map.upper_bound(x);
    // retorna interador para primeiro elemento > x
    

\end{verbatim}

\subsection{Set}    
    O set é utilizado para a criação de "vetores" ordenados. NÃO permite duplicatas
    \begin{verbatim}
        set<int> set; 

        // O(log n)
        name_set.insert(k);

        // O(log n)
        auto it = set.find(k);

        // O(1)
        set.erase(it);

        // O(log n)
        set.erase(k);

        // O(n) - n = final-inicial
        set.erase(it_inicial, it_final)
        
        // O(log n)
        set.lower_bound(x);

        // O(log n)
        set.upper_bound(x);
    \end{verbatim}

\subsection{MultiSet} 

Muito semelhante ao set, mas permite duplicatas

\subsection{Bitset}
    Maneira de armazenar uma string binária de forma eficiente, com complexidade O(n/32) e O(n/64). A utilização pode ser feita da mesma forma que vetores, com a condição da estrutura favorecer operações bit a bit.

    Transformação de número em bitset (número binário)
    \begin{verbatim}
bitset<n> nome(k); 
/*criar bitset de tamanho n (conhecido em tempo de compilação) 
que armazena o número k.*/
    \end{verbatim}

\pagebreak